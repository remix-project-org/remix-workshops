Remix IDE is a browser-based (also includes a desktop variant) development environment for building, testing, and shipping smart contracts. It’s designed to remove setup friction, make feedback loops tight, and help you reason about what’s really happening on-chain.

This page explains what Remix is for, how it’s structured, and the mental model to bring to it.

## Why Remix?

Writing smart contracts without Remix often starts with setup work that distracts from the code. First, you have to setup a local development environment by installing Node.js so JavaScript-based tools and CLIs can run, adding a Solidity compiler that matches your code so builds are deterministic.You also have to choose a framework like Hardhat or Foundry for compilation, testing, scripting, and deployments.

You might also include plugins like Ethers/Web3 for calls, coverage and gas reporters for quality, and linters or formatters for consistency. All this is before you write a single line of contract code.

Remix compresses this process in your browser and all you need to do is open a URL (remix.ethereum.org), write Solidity (or Vyper via plugin), compile, deploy to a network, and interact with your contracts, all in one place.

## How Remix is Structured

Think of Remix as three layers:

### Workspace & Files

Your code lives in a workspace: folders and files you can create, import, or connect to external sources. Remix stores data in the browser (IndexedDB) or via integrations; you can export at any time.

### Plugins

Everything in Remix is a plugin, even “core” modules, so you can enable/disable to fit your flow. Some examples of core plugins include:

- **File Explorer**: Allows you to navigate and manage files in Remix.
- **Compiler**: Turns Solidity/Vyper into bytecode and ABI.

- **Deploy & Run**: Sends transactions, deploys contracts, and lets you call functions.

- **Debugger**: Steps through transactions with stack, memory, and storage views.

- **Static Analysis & Linting**: Catches common pitfalls before you ship.

### Network & Accounts

Remix can talk to a local VM (in-browser EVM for fast iteration), testnets, or mainnets via a provider. Accounts can be generated by Remix’s in-memory VM or injected from wallet extensions. You choose the environment each time you deploy or run a call.
