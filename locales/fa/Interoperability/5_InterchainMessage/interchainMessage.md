در این بخش قراردادی ایجاد خواهیم کرد که پیام «سلام دنیا» را بین دو بلاکچین ارسال می‌کند.

## سازنده

اولین چیزی که باید ایجاد کنید، «سازنده» constructor برای تابع است. این به شما امکان می‌دهد قراردادهای «دروازه» و «سرویس گاز» را که در بخش‌های قبلی مورد بحث قرار دادیم، تنظیم کنید.

هنگام استقرار قرارداد، آدرس‌های «Gateway» و «GasService» را برای اتریوم سپولیا وارد خواهید کرد. این آدرس‌ها برای Gateway به صورت `0xe432150cce91c13a887f7D836923d5597adD8E31` و برای Gas Service به صورت `0xbE406F0189A0B4cf3A05C286473D23791Dd44Cc6` هستند.

برای لیست کامل آدرس‌های مرتبط Axelar <a href="https://docs.axelar.dev/resources/contract-addresses/testnet" target="_blank">اینجا را ببینید</a>

## ارسال پیام Interchai

اکنون که سازنده، آدرس‌های Axelar مربوط را که برای راه‌اندازی یک تراکنش بین‌زنجیره‌ای مورد نیاز هستند، تنظیم کرده است، می‌توانید به سراغ `setRemoteValue()` بروید که این تراکنش را راه‌اندازی می‌کند.

این تابع سه پارامتر می‌گیرد:

1. `_destinationChain`: زنجیره‌ای که تراکنش قرار است به آن منتقل شود
2. `_destinationAddress`: آدرسی در زنجیره مقصد که تراکنش در آن اجرا خواهد شد
3. `_message`: پیامی که به زنجیره مقصد ارسال می‌شود

اول، شما یک دستور `require` دارید که تضمین می‌کند `msg.value` حاوی یک مقدار باشد. این «msg.value» برای پرداخت «خدمات گاز» استفاده خواهد شد. اگر هیچ وجهی ارسال نشده باشد، تراکنش باید برگردانده شود زیرا تراکنش بدون هیچ گونه سوختی نمی‌تواند در بلاکچین Axelar و زنجیره مقصد اجرا شود.

در مرحله بعد، شما `_message` ارسال شده را کدگذاری می‌کنید. توجه داشته باشید که `_message` به عنوان نوع `string` تنظیم شده است. Axelar انتظار دارد که این پیام به عنوان یک نوع `bytes` ارسال شود، بنابراین برای تبدیل `string` به `bytes`، کافیست آن را از طریق `abi.encode()` ارسال کنید.

اکنون، با رمزگذاری پیام خود، می‌توانید با «GasService» و «Gateway» تعامل داشته باشید

برای پرداخت کل تراکنش بین زنجیره‌ای، تابع `payNativeGasForContractCall` را که در `GasService` تعریف شده است، فعال خواهید کرد.

این تابع به پارامترهایی که قبلاً در بخش GasService توضیح داده شده است، نیاز دارد. «فرستنده» این تراکنش، این قرارداد خواهد بود که «address(this)» است. «destinationChain» و «destinationAddress» می‌توانند به سادگی از پارامترهای این تابع ارسال شوند، «payload» همان پیام رمزگذاری شده‌ای است که قبلاً نوشتیم. در نهایت، باید آدرس بازپرداخت را مشخص کنید، این می‌تواند آدرسی باشد که این تابع را فعال می‌کند، که با نوشتن `msg.sender` به آن دست می‌یابید.

به محض اینکه این تابع را فعال کنید، با موفقیت یک تراکنش را از زنجیره مبدا از طریق Axelar به زنجیره مقصد ارسال کرده‌اید! اما هنوز یک مرحله نهایی باقی مانده که باید تکمیل شود.

### دریافت پیام در زنجیره مقصد

در زنجیره مقصد، تراکنش بین زنجیره‌ای ورودی باید توسط تابع `_execute()` از `AxelarExecutable` دریافت و مدیریت شود.

تابع `_execute()` در قرارداد `AxelarExecutable` تعریف شده است، بنابراین هنگام تعریف این تابع باید به یاد داشته باشید که کلمه کلیدی `override` را وارد کنید.

این تابع سه پارامتر می‌گیرد.

1. `_sourceChain`: بلاکچینی که تراکنش از آن سرچشمه گرفته است
2. `_sourceAddress`: آدرسی در زنجیره مبدا که تراکنش از آن ارسال شده است
3. `_payload`: پیامی که از زنجیره منبع ارسال شده است

اولین کاری که باید در این قرارداد انجام شود، دسترسی به «پیام» ارسالی شماست. به یاد بیاورید، قبل از ارسال پیام، از طریق `abi.encode()` ارسال شد تا پیام از نوع `string` به نوع `bytes` تبدیل شود. برای تبدیل پیام خود از نوع «بایت» به نوع «رشته»، کافیست `_payload` را به تابع `abi.decode()` ارسال کنید و مشخص کنید که می‌خواهید `_payload` از نوع `رشته` رمزگشایی شود. این متد، پیام را به صورت یک رشته برمی‌گرداند.

حالا که پیام شما از نوع رشته است، می‌توانید متغیرهای ذخیره‌سازی `sourceChain` و `sourceAddress` را به صورت `_sourceChain` و `_sourceAddress` تنظیم کنید تا ارجاعی آسان به داده‌های ارسالی داشته باشید. همچنین می‌توانید رویداد `Executed` را با رویدادهای `sourceAddress` و `message` که رمزگشایی کرده‌اید، منتشر کنید.

عالیه! در این مرحله، شما در حال مدیریت تراکنش بین زنجیره‌ای در زنجیره مقصد هستید.

برای تعامل با این قرارداد، مطمئن شوید که آن را حداقل روی دو بلاکچین مستقر کرده‌اید تا بتوانید `setRemoteValue()` را از یک زنجیره فراخوانی کنید و سپس تابع `_execute()` را به طور خودکار روی زنجیره دیگر فعال کنید. شما قادر خواهید بود متغیرهای `sourceChain` و `sourceAddress` را در زنجیره مقصد جستجو کنید تا از صحت اجرای بین زنجیره‌ای اطمینان حاصل کنید.

برای مشاهده‌ی گام به گام کامل تراکنش‌های بین زنجیره‌ای، به <a href="https://testnet.axelarscan.io" target="_blank">کاوشگر بلوک Axelarscan (شبکه‌ی آزمایشی)</a> مراجعه کنید.
