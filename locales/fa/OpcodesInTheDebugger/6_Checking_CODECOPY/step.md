هدف اینجا ذخیره کد در بلاکچین است. EVM باید به کلاینت (geth، parity) بگوید که کدام قسمت از **داده‌های تماس** را ذخیره کند.   در این مرحله، ما قرارداد را به اضافه ی کد سازنده‌اش ذخیره می‌کنیم (زیرا که تنها یک بار پیاده‌سازی 1 می‌شود) و همچنین پارامتر ورودی نیازی به ذخیره شدن ندارد.

`CODECOPY` اولین مرحله است: این کد بایت را به حافظه کپی می‌کند، سپس کلاینت اتریوم قادر خواهد بود از آن استفاده کند.  بخور!

اما صبر کنید... قبل از اینکه مشتری بتواند بایت کد را **بلع** کند، به یک دستور - یک کد عملیاتی نیاز دارد که به آن بگوید بلع کند. `RETURN` این کد عملگری است!

همانطور که در مشخصات عمومی بیان شده است، در انتهای ایجاد قرارداد، کلاینت (geth، parity) مقدار هدفمند را با استفاده از کد عملیاتی `RETURN` گرفته و آن را با قرار دادن در بایت کد منتشر شده، **مستمر** می‌کند.

Once you are in the `CODECOPY`, look at the top 3 items in the **Stack**:

`0: 0x0000000000000000000000000000000000000000000000000000000000000000`
`1: 0x0000000000000000000000000000000000000000000000000000000000000055`
`2: 0x000000000000000000000000000000000000000000000000000000000000003e`

_در استک شما - `1` و `2` ممکن است کمی متفاوت باشند.  تفاوت ممکن است به دلیل نسخه متفاوت کامپایلر باشد._

**اینها پارامترهای `CODECOPY` هستند.**

به خاطر داشته باشید: _codecopy(t, f, s)_ - **s** بایت از کد در موقعیت **f** را به حافظه در موقعیت **t** کپی کنید

`0` is the offset where the copied code should be placed in the **memory**. در این مثال، (همه صفرها) کد به ابتدای حافظه کپی می‌شود. (**t**) `1` جایگاهی در **calldata** است که باید از آن کپی شود (**f**) `2` تعداد بایت‌هایی که باید کپی شوند - (**s**)

پس از اجرای `CODECOPY`، (برای رفتن به مرحله بعد دکمه _ورود به مرحله_ را بزنید) کد کپی‌شده باید در حافظه به صورت زیر باشد: `0x6080604052600080fdfea265627a7a7231582029bb0975555a15a155e2cf28e025c8d492f0613bfb5cbf96399f6dbd4ea6fc9164736f6c63430005110032`.  **من به این مقدار (X) اشاره می‌کنم.**.

بیایید به پنل **حافظه** دیباگر نگاه کنیم.
شماره 0x که بالاتر دادم، همان چیزی نیست که در پنل **حافظه** خواهید دید - آنچه خواهید دید این است:0x0: 6080604052600080fdfea265627a7a72 ؟؟؟؟R؟؟؟؟؟؟ebzzr0x10: 31582029bb0975555a15a155e2cf28e0 1X ؟؟ uUZ؟؟U؟؟؟؟
0x20: 25c8d492f0613bfb5cbf96399f6dbd4e ؟؟؟؟؟a؟؟؟؟؟9؟m؟N
0x30: a6fc9164736f6c634300051100320000 ؟؟؟dsolcC؟؟؟؟2؟؟
0x40: 00000000000000000000000000000000 ؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟
0x50: 000000000000000000000000000000a0 ؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟
0x60: 00000000000000000000000000000000 ؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟
0x70: 00000000000000000000000000000000 ؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟
0x80: 00000000000000000000000000000000 ؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟
0x90: 00000000000000000000000000000002 ؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟

`0x0`، `0x10` و غیره موقعیت هستند. The `0x0`, `0x10`, etc is the position.  این با علامت‌های سؤال و به نظر می‌رسد حروف و اعداد تصادفی دنبال می‌شود.  این تلاش **Remix** برای تبدیل این به یک رشته است.

So if we glue the first four sections of bytecode together, we'll get:
**0x6080604052600080fdfea265627a7a7231582029bb0975555a15a155e2cf28e0a6fc9164736f6c63430005110032**  The last section - `0x90` has 2 which is what I input for the constructors parameter.

داده‌های ورودی از پنل**داده‌های تماس** به صورت زیر است:`0x6080604052348015600f57600080fd5b506040516093380380609383398181016040526020811015602f57600080fd5b81019080805190602001909291905050508060008190555050603e8060556000396000f3fe6080604052600080fdfea265627a7a7231582029bb0975555a15a155e2cf28e025c8d492f0613bfb5cbf96399f6dbd4ea6fc9164736f6c634300051100320000000000000000000000000000000000000000000000000000000000000002`**من به این مقدار (Y) اشاره خواهم کرد.**

این به ما نشان می‌دهد که `(X)` یک زیرمجموعه از کالددات اصلی `(Y)` است:

`(X)` کال دیتا بدون پارامتر ورودی `0000000000000000000000000000000000000000000000000000000000000002` (ما نیازی به ذخیره سازی این نداریم) و بدون کد سازنده `6080604052348015600f57600080fd5b506040516093380380609383398181016040526020811015602f57600080fd5b81019080805190602001909291905050508060008190555050603e8060556000396000f3fe` که فقط باید یک بار اجرا 1 شود.

بنابراین `CODECOPY` بایت‌کد را از کالادیتا استخراج کرده و آن را به حافظه کپی می‌کند.

بیایید به مرحله بعدی برویم.
