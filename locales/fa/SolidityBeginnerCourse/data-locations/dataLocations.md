مقدار متغیرها در سالیدیتی می‌تواند در مکان‌های داده مختلف ذخیره شود: _حافظه_، _ذخیره‌سازی_ و _کال‌داده_.

همانطور که قبلاً بحث کردیم، متغیرهای نوع مقدار یک نسخه مستقل از یک مقدار را ذخیره می‌کنند، در حالی که متغیرهای نوع مرجع (آرایه، ساختار، نگاشتن) تنها موقعیت (ارجاع) مقدار را ذخیره می‌کنند.

اگر ما از یک نوع مرجع در یک عملکرد استفاده کنیم، باید تعیین کنیم که مقادیر آنها در کدام مکان داده ذخیره شده‌اند. قیمت اجرای تابع تحت تأثیر محل داده‌هاست؛ ایجاد کپی از انواع مرجع هزینه گاز می‌برد.

### ذخیره‌سازی

مقدارهای ذخیره شده در _ذخیره‌سازی_ به‌صورت دائمی در بلاکچین ذخیره می‌شوند و به همین دلیل، استفاده از آن‌ها هزینه‌بر است.

در این قرارداد، متغیرهای دولتی `arr`، `map` و `myStructs` (خطوط ۵، ۶ و ۱۰) در حافظه ذخیره می‌شوند. متغیرهای حالت همیشه در حافظه ذخیره می‌شوند.

### حافظه

مقادیر ذخیره شده در _حافظه_ تنها به صورت موقتی ذخیره می‌شوند و در بلاک‌چین نیستند. آنها تنها در طول اجرای یک تابع خارجی وجود دارند و بعد از آن کنار گذاشته می‌شوند. استفاده از آنها ارزان‌تر از مقادیری است که در _ذخیره‌سازی_ نگهداری می‌شوند.

در این قرارداد، متغیر محلی `myMemstruct` (خط 19) و همچنین پارامتر `_arr` (خط 31) در حافظه ذخیره می‌شوند. پارامترهای تابع باید محل داده _حافظه_ یا _کال دیتا_ داشته باشند.

### کال دیتا

_کال دیتا_ آرگومان‌های تابع را ذخیره می‌کند. مانند _حافظه_، _کالldata_ تنها در طول اجرای یک تابع خارجی به طور موقت ذخیره می‌شود. برخلاف مقادیری که در _حافظه_ ذخیره شده‌اند، مقادیر ذخیره شده در _کال‌داده_ نمی‌توانند تغییر کنند. کالldata ارزان‌ترین موقعیت داده‌ای است که می‌توان از آن استفاده کرد.

در این قرارداد، پارامتر `_arr` (خط ۳۵) محل داده _calldata_ دارد. اگر ما می‌خواستیم یک مقدار جدید به عنصر اول آرایه `_arr` اختصاص دهیم، می‌توانستیم این کار را در `تابع g` (خط ۳۱) انجام دهیم اما در `تابع h` (خط ۳۵) نمی‌توانستیم. این به این دلیل است که `_arr` در `تابع g` مکان داده _حافظه_ و _تابع h_ مکان داده `calldata` دارد.

## تکالیف

### از حافظه به حافظه

تأ assignments از _حافظه_ به _حافظه_ به جای کپی، ارجاعات ایجاد می کند. اگر شما مقدار یک متغیر را تغییر دهید، مقدار تمام متغیرهای دیگری که به همان داده اشاره می‌کنند تغییر خواهد کرد.

اگر ما بخواهیم یک ساختار جدید به نام `myMemStruct2` با محل داده _memory_ در داخل `function f` (خط 12) ایجاد کنیم و مقدار آن را به `myMemStruct` (خط 19) نسبت دهیم، هرگونه تغییر در `myMemStruct2` همچنین مقدار `myMemStruct` را تغییر خواهد داد.

### ذخیره‌سازی به حافظه محلی

انتقال‌ها از _ذخیره‌سازی_ به _ذخیره‌سازی محلی_ نیز مراجع اشاره‌ها می‌سازند، نه کپی‌ها.

اگر ما مقدار متغیر محلی `myStruct` (خط 17) را تغییر دهیم، مقدار متغیر حالت ما `myStructs` (خط 10) نیز تغییر می‌کند.

## ذخیره‌سازی و حافظه/داده‌های ورودی

انتساب‌ها بین _ذخیره‌سازی_ و _حافظه_ (یا _کال‌داده_) کپی‌های مستقل ایجاد می‌کنند، نه مراجع.

اگر ما بخواهیم یک ساختار جدید به نام `myMemStruct3` با محل داده _memory_ در داخل `function f` (خط 12) ایجاد کنیم و مقدار آن را به `myStruct` تخصیص دهیم، تغییرات در `myMemStruct3` بر ارزش‌های ذخیره شده در نگاشت `myStructs` (خط 10) تأثیری نخواهد داشت.

همان‌طور که در ابتدای کار گفتیم، هنگام ایجاد قراردادها باید به هزینه‌های گاز توجه داشته باشیم. بنابراین، ما نیاز داریم از مکان‌های داده‌ای استفاده کنیم که کمترین میزان گاز ممکن را نیاز دارند.

## ⭐️ تکلیف

1. مقدار عضو `foo` از `myStruct` را در داخل تابع `f` به ۴ تغییر دهید.
2. یک ساختار جدید به نام `myMemStruct2` با مکان داده _memory_ داخل تابع `f` ایجاد کنید و آن را به مقدار `myMemStruct` اختصاص دهید. مقدار عضو `foo` در `myMemStruct2` را به ۱ تغییر دهید.
3. یک ساختار جدید به نام `myMemStruct3` ایجاد کنید که موقعیت داده `*memory*` را درون `تابع f` داشته باشد و آن را به مقدار `myStruct` اختصاص دهید. مقدار عضو `foo` در ساختار `myMemStruct3` را به ۳ تغییر دهید.
4. بگذارید تابع f مقادیر `myStruct`، `myMemStruct2` و `myMemStruct3` را بازگرداند.

نکته: اطمینان حاصل کنید که انواع بازگشتی صحیحی برای تابع ایجاد کرده‌اید.