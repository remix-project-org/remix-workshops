در این بخش، ما یاد خواهیم گرفت که چگونه یک قرارداد می‌تواند اتریوم ارسال و دریافت کند.

### ارسال اتریوم

ما سه گزینه مختلف برای انتقال اتر داریم: `transfer()`، `send()` و `call()`.

#### تراکنش ها

`<address payable>.انتقال(مقدار uint256)`

- `transfer()` در صورت شکست یک استثنا را پرتاب می‌کند
- یک کمک هزینه ثابت ۲۳۰۰ گازی را پیش‌پرداخت می‌کند

یک نمونه از `transfer()` را می‌توان در قرارداد `SendEther` (خط ۳۵) دید.
**استفاده از `Transfer()` دیگر توصیه نمی‌شود.**

#### **ارسال**

`<address payable>.ارسال(uint256 مقدار) بازگشت (bool)`

- `send()` در صورت عدم موفقیت، false را برمی‌گرداند
- یک کمک هزینه ثابت ۲۳۰۰ گازی را پیش‌پرداخت می‌کند

یک نمونه از `send()` را می‌توان در قرارداد `SendEther` (خط ۴۱) دید.
**`Send()` دیگر توصیه نمی‌شود که استفاده شود.**

#### **تماس**

`<address>.صدا بزن (حافظه بایت‌ها) باز می‌گرداند (بول، حافظه بایت‌ها)`

- `call()` در صورت عدم موفقیت، false را برمی‌گرداند
- حداکثر مقدار گاز را به جلو می‌فرستد، اما این قابل تنظیم است

یک نمونه از `call()` را می‌توان در قرارداد `SendEther` (خط ۴۸) دید.
`Call()` در حال حاضر برای انتقال اتر توصیه می‌شود.

دلیل معرفی `transfer()` و `send()` برای محافظت در برابر _حملات ورودی مجدد_ از طریق محدود کردن گاز ارسال شده به ۲۳۰۰ بود، که برای انجام یک تماس ورودی مجدد که می‌تواند ذخیره‌سازی را تغییر دهد، کافی نخواهد بود.

همانطور که در بخش گذشته بحث کردیم، هر عملیات در اتریوم هزینه خاصی مرتبط با خود دارد. برخی عملیات به مرور زمان هزینه بیشتری یافته‌اند، بنابراین هزینه‌های گاز مربوط به آن‌ها نیز افزایش یافته است. زمانی که هزینه‌های گاز برای عملیات ممکن است تغییر کند، استفاده از مقدار گاز سخت‌افزاری مانند transfer() و send() مناسب نیست.

به همین دلیل اکنون استفاده از `call()` به جای `transfer()` برای ارسال اتر توصیه می‌شود.

بیشتر در مورد موضوع در این <a href="https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/" target="_blank">پست وبلاگ کنسنسس</a> بیاموزید.

### حمله بازگشت پذیری

یک _حمله بازگشتی_ زمانی رخ می‌دهد که یک تابع به یک قرارداد غیرقابل اعتماد تماس می‌گیرد و مهاجم از قرارداد برای انجام تماس‌های بازگشتی به تابع اصلی قبل از اتمام اجرای آن استفاده می‌کند. با این روش، مهاجم می‌تواند وجوه را تخلیه کرده و داده‌ها را به روش‌های غیرمنتظره دستکاری کند.

برای جلوگیری از حمله _بازگشتی_، تمام تغییرات وضعیت باید قبل از فراخوانی یک قرارداد خارجی انجام شود. این الگو همچنین به نام الگوی <a href="https://docs.soliditylang.org/en/latest/security-considerations.html#re-entrancy" target="_blank">بررسی‌ها-اثرها-تعاملات</a> شناخته می‌شود.

یک روش دیگر برای جلوگیری از بازگشت مجدد این است که از _نگهبان بازگشت مجدد_ استفاده کنیم که چنین تماس‌هایی را بررسی کرده و آنها را رد می‌کند. شما می‌توانید یک نمونه از این را در قرارداد در بخش تغییرات ما مشاهده کنید یا نسخه‌ای با مصرف گاز کمتر را در <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol" target="_blank">Open Zepplin</a> ببینید.

### دریافت اتریوم

اگر می‌خواهیم که یک قرارداد بتواند اتریوم دریافت کند بدون اینکه تابعی فراخوانی شود، باید یک تابع `receive` (خط ۲۲) یا یک تابع `fallback` (خط ۲۵) ایجاد کنیم؛ در غیر این صورت، اتریوم رد خواهد شد و قرارداد یک استثنا پرتاب خواهد کرد.

تابع `receive` در درخواست‌هایی با calldata خالی اجرا می‌شود (برای مثال انتقال‌های ساده اتر از طریق send() یا transfer())، در حالی که تابع fallback در درخواست‌هایی با calldata اجرا می‌شود. اگر هیچ تابع دریافت‌کننده‌ای وجود نداشته باشد اما یک تابع جایگزین وجود داشته باشد، تماس‌هایی با کد calldata خالی نیز از تابع جایگزین استفاده خواهند کرد.

### تعدیل کننده تابع قابل پرداخت

مودیفایر تابع `payable` اجازه می‌دهد که یک تابع اتر دریافت کند.

تابع `receive` (خط ۲۲) نیاز دارد که `payable` باشد. اگر شما اصلاح‌گر `payable` را حذف کنید، یک خطا از کامپایلر دریافت خواهید کرد. اگر modifier `payable` را از تابع `fallback` (خط 25) حذف کنید، کامپایل خواهد شد، اما نمی‌تواند اتر دریافت کند.
توابع `sendViaTransfer`، `sendViaSend` و `sendViaCall` (خطوط ۳۳، ۳۸ و ۴۵) همچنین باید `payable` باشند تا قادر به دریافت اتر باشند.

### آدرس

زبان Solidity تفاوتی بین دو نوع مختلف از نوع داده آدرس ایجاد می‌کند: آدرس و آدرس قابل پرداخت.

`address`: یک مقدار 20 بایتی را نگه می‌دارد.
`آدرس قابل پرداخت`: یک مقدار 20 بایتی را نگه می‌دارد و می‌تواند از طریق اعضای خود: انتقال و ارسال، اتر دریافت کند.

اگر نوع پارامترها را برای توابع `sendViaTransfer` و `sendViaSend` (سطح 33 و 38) از `payable address` به `address` تغییر دهید، نخواهید توانست از `transfer()` (سطح 35) یا `send()` (سطح 41) استفاده کنید.

<a href="https://www.youtube.com/watch?v=_5vGaqgzlG8" target="_blank">یک آموزش ویدیویی درباره ارسال اتر را تماشا کنید</a>.

## ⭐️ تکلیف

یک قرارداد خیریه بسازید که اتریوم را دریافت کند و توسط یک ذینفع قابل برداشت باشد.

1. یک قرارداد به نام `خیریه` ایجاد کنید.
2. یک متغیر عمومی به نام `owner` از نوع آدرس اضافه کنید.
3. یک تابع اهدا ایجاد کنید که عمومی و قابل پرداخت باشد و بدون هیچ پارامتر یا کدی از تابع باشد.
4. یک تابع برداشت ایجاد کنید که عمومی باشد و کل موجودی قرارداد را به آدرس `owner` ارسال کند.

نکته: قرارداد خود را با مستقر کردن آن از یک حساب آزمایش کنید و سپس از حساب دیگری به آن اتریوم ارسال کنید. سپس تابع برداشت را اجرا کنید.